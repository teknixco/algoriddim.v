//+------------------------------------------------------------------+
//|                                              Vic The Millionaire |
//|                   Copyright 2021-2022, Teknix International LLC  |
//|                                 http://www.github.com/victorekpo |
//+------------------------------------------------------------------+
#property copyright   "2021-2022, Teknix International LLC"
#property link        "http://www.github.com/victorekpo"
#property description "Million Dollar BOT for BOOM/CRASH Indices"

//---  Declare Libraries
#include <Trade\PositionInfo.mqh>
#include <Trade\Trade.mqh>
#include <mq4_mq5_bridge.mqh>
// #include <Trade\OrderInfo.mqh>
// #include <Charts\Chart.mqh>

CPositionInfo  m_position;                   // trade position object
CTrade         m_trade;                      // trading object
// CChart         m_chart;                      // chart object
// COrderInfo     m_order;

#define MILLIONDOLLARBOT  20220527

////--- Declare Inputs
//input int defaultMAXSteps = 10;
//input int defaultMAXOrders = 2;
//input int defaultOrderCount = 1;
//---  Declare variables
// Set Handles
int MAHandle_60_200 = INVALID_HANDLE;
int MAHandle_60_50 = INVALID_HANDLE;
int MAHandle_60_20 = INVALID_HANDLE;
int MAHandle_60 = INVALID_HANDLE;
int MAHandle_30_200 = INVALID_HANDLE;
int MAHandle_30_50 = INVALID_HANDLE;
int MAHandle_30_20 = INVALID_HANDLE;
int MAHandle_30 = INVALID_HANDLE;
int MAHandle_15_200 = INVALID_HANDLE;
int MAHandle_15_50 = INVALID_HANDLE;
int MAHandle_15_20 = INVALID_HANDLE;
int MAHandle_15 = INVALID_HANDLE;
int MAHandle_5_200 = INVALID_HANDLE;
int MAHandle_5 = INVALID_HANDLE;
int MAHandle_5_20 = INVALID_HANDLE;
int MAHandle_5_9 = INVALID_HANDLE;
int MAHandle_1_9 = INVALID_HANDLE;
int MAHandle_1_20 = INVALID_HANDLE;
int MAHandle_1_50 = INVALID_HANDLE;
int MAHandle_1_200 = INVALID_HANDLE;
int RSIHandle_1_14 = INVALID_HANDLE;

int xnotify;
int accountMarg;
int maxLimits;
int maxLoop;

double curBuys[100];
double curSells[100];
double lowestProf[100];
double highestProf[100];
double orderTime[100];

//Regular Variables
string currentMarket;
string previousMarket;
string MAStatus_15_200, MAStatus_15, MAStatus_5, MAStatus_1_9, MAStatus_1_50;
string MAStatusLast_15_200, MAStatusLast_15, MAStatusLast_5, MAStatusLast_1_9, MAStatusLast_1_50;
string MASignal_15_200, MASignal_15, MASignal_5, MASignal_1_9, MASignal_1_50;
bool MAReachUp_15_200, MAReachUp_15, MAReachUp_5, MAReachUp_1_9, MAReachUp_1_50;
bool MACross_15_200, MACross_15, MACross_5, MACross_1_9, MACross_1_20;
bool MAReachDown_15_200, MAReachDown_15, MAReachDown_5, MAReachDown_1_9, MAReachDown_1_50;
int orderPlaced, RandomNumber, steps, buycount1, buycount2, sellcount1, sellcount2;
int num=1;
int tickCount=0;
double currentPrice,
       currentLow_M1, currentLow_M5, currentLow_M15, currentLow_M30, currentLow_H1,
       currentHigh_M1, currentHigh_M5, currentHigh_M15, currentHigh_M30, currentHigh_H1,
       priceHighest_M1, priceHighest_M1_75, priceHighest_M1_37, priceLowest_M1, priceLowest_M1_75, priceLowest_M1_37,
       priceHighest_M5, priceLowest_M5,
       priceHighest_M15, priceLowest_M15,
       priceHighest_M30, priceLowest_M30,
       priceHighest_H1, priceLowest_H1,
       priceLast,
       lowLast_M1, lowLast_M5, lowLast_M15, lowLast_M30, lowLast_H1,
       highLast_M1, highLast_M5, highLast_M15, highLast_M30, highLast_H1,
       highestProfit,notifyCount,highestPrice3Day,highestPrice3Day_diff,
       lowestPrice3Day,lowestPrice3Day_diff,lowestPrice3DayLast;
double lowestProfit = -9999;
double takeProfit = 3;
long volumeLast,barSize,barSizeLast;
int MAXSteps;
int MAXOrders;
int orderCount;
bool continueOrders = true;
bool takeMoreOrders = false;
int lastBull1,lastBull2,lastBull3,lastBull4,lastBull5,lastBull6,lastBull7,lastBull8,lastBull9,lastBull10;


//---  Declare functions
int OnInit()
  {
   MAHandle_60_200 = iMA(NULL, PERIOD_H1, 200, 0, MODE_SMA, PRICE_CLOSE);
   MAHandle_60_50 = iMA(NULL, PERIOD_H1, 50, 0, MODE_SMA, PRICE_CLOSE);
   MAHandle_60_20 = iMA(NULL, PERIOD_H1, 20, 0, MODE_SMA, PRICE_CLOSE);
   MAHandle_60 = iMA(NULL, PERIOD_H1, 9, 0, MODE_SMA, PRICE_CLOSE);
   MAHandle_30_200 = iMA(NULL, PERIOD_M30, 200, 0, MODE_SMA, PRICE_CLOSE);
   MAHandle_30_50 = iMA(NULL, PERIOD_M30, 50, 0, MODE_SMA, PRICE_CLOSE);
   MAHandle_30_20 = iMA(NULL, PERIOD_M30, 20, 0, MODE_SMA, PRICE_CLOSE);
   MAHandle_30 = iMA(NULL, PERIOD_M30, 9, 0, MODE_SMA, PRICE_CLOSE);
   MAHandle_15_200 = iMA(NULL, PERIOD_M15, 200, 0, MODE_SMA, PRICE_CLOSE);
   MAHandle_15_50 = iMA(NULL, PERIOD_M15, 50, 0, MODE_SMA, PRICE_CLOSE);
   MAHandle_15_20 = iMA(NULL, PERIOD_M15, 20, 0, MODE_SMA, PRICE_CLOSE);
   MAHandle_15 = iMA(NULL, PERIOD_M15, 9, 0, MODE_SMA, PRICE_CLOSE);
   MAHandle_5_200 = iMA(NULL, PERIOD_M5, 200, 0, MODE_SMA, PRICE_CLOSE);
   MAHandle_5 = iMA(NULL, PERIOD_M5, 50, 0, MODE_SMA, PRICE_CLOSE);
   MAHandle_5_20 = iMA(NULL, PERIOD_M5, 20, 0, MODE_SMA, PRICE_CLOSE);
   MAHandle_5_9 = iMA(NULL, PERIOD_M5, 9, 0, MODE_SMA, PRICE_CLOSE);
   MAHandle_1_9 = iMA(NULL, PERIOD_M1, 9, 0, MODE_SMA, PRICE_CLOSE);
   MAHandle_1_20 = iMA(NULL, PERIOD_M1, 20, 0, MODE_SMA, PRICE_CLOSE);
   MAHandle_1_50 = iMA(NULL, PERIOD_M1, 50, 0, MODE_SMA, PRICE_CLOSE);
   MAHandle_1_200 = iMA(NULL, PERIOD_M1, 200, 0, MODE_SMA, PRICE_CLOSE);
   RSIHandle_1_14 = iRSI(NULL, PERIOD_M1, 14, PRICE_CLOSE);
   if(MAHandle_60_200 == INVALID_HANDLE || MAHandle_60_50 == INVALID_HANDLE || MAHandle_60_20 == INVALID_HANDLE || MAHandle_60 == INVALID_HANDLE
      || MAHandle_30_200 == INVALID_HANDLE || MAHandle_30_50 == INVALID_HANDLE || MAHandle_30_20 == INVALID_HANDLE || MAHandle_30 == INVALID_HANDLE
      || MAHandle_15_200 == INVALID_HANDLE || MAHandle_15_50 == INVALID_HANDLE || MAHandle_15_20 == INVALID_HANDLE || MAHandle_15 == INVALID_HANDLE
      || MAHandle_5_200 == INVALID_HANDLE || MAHandle_5 == INVALID_HANDLE || MAHandle_5_20 == INVALID_HANDLE || MAHandle_5_9 == INVALID_HANDLE
      || MAHandle_1_200 == INVALID_HANDLE || MAHandle_1_50 == INVALID_HANDLE || MAHandle_1_20 == INVALID_HANDLE || MAHandle_1_9 == INVALID_HANDLE
      || RSIHandle_1_14 == INVALID_HANDLE
     )
     {
      Print("Error creating indicator");
      return(INIT_FAILED);
     }
//--- create timer
   EventSetTimer(1);
//---
   return (INIT_SUCCEEDED);
  }

//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+
ENUM_TIMEFRAMES setTimeFrame(int time)
  {
   if(time==1)
     {
      return PERIOD_M1;
     }
   if(time==5)
     {
      return PERIOD_M5;
     }
   if(time==15)
     {
      return PERIOD_M15;
     }
   if(time==30)
     {
      return PERIOD_M30;
     }
   if(time==60)
     {
      return PERIOD_H1;
     }

   if(time==240)
     {
      return PERIOD_H4;
     }

   if(time==999)
     {
      return PERIOD_D1;
     }
   return 0;
  }
//+------------------------------------------------------------------+
//| Check if the current bar is BULLISH                              |
//+------------------------------------------------------------------+
bool isThisBarBULLISH(int time = 1, int period = 0)
  {
   return (iClose(Symbol(),setTimeFrame(time),period) > iOpen(Symbol(),setTimeFrame(time),period));
  }

//+------------------------------------------------------------------+
//| Check if the current bar is BEARISH                              |
//+------------------------------------------------------------------+
bool isThisBarBEARISH(int time = 1, int period=0)
  {
   return (iClose(Symbol(),setTimeFrame(time),period) < iOpen(Symbol(),setTimeFrame(time),period));
  }

//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+
int getStepsLastBull(int time,int period=0)
  {
   int count = 1;
   bool found = false;
// int count = 0;

   while(found == false)
     {
      if(isThisBarBULLISH(time,period) == true)
        {
         found = true;
         return count;
        }
      count++;
      period++;
     }
   return count;
  }

//Function to calculate Percentage Difference Between Two Numbers
//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+
double percdiff(double val1, double val2)
  {
//val2 > val1
   double result;
   if(val2 == 0 || val1 == 0)
     {
      result = 0;
      return result;
     }
   if(val2 > val1)
      result = MathAbs((MathAbs(val1)/MathAbs(val2)*100)-100)*10;
   if(val1 > val2)
      result = MathAbs((MathAbs(val2)/MathAbs(val1)*100)-100)*10;
   return(result);
  };
//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+
double percdiff_signed(double val1, double val2)
  {
//val2 > val1
   double result;
   if(val2 == 0)
     {
      val2 =1;
     }
   result = ((MathAbs(val1)/MathAbs(val2)*100)-100)*10;
   return(result);
  };


//Function to get Random Number Within a Range
//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+
int RandNum()
  {
//loop keeps running until it finds a random number less than bounds
   for(int n = 0; n < 1; n++)
     {
      RandomNumber = MathRand();
      if(RandomNumber > 1 || RandomNumber < 0)
        {
         n--;
        }
     };
   return RandomNumber;
  };

//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+
string setMarket()
  {
   currentMarket = "unset";  // initial state of market
   if(isThisBarBULLISH(15) && isThisBarBULLISH(30) && isThisBarBULLISH(60))
      currentMarket = "bull";
   if(isThisBarBULLISH(15) && isThisBarBULLISH(30) && isThisBarBULLISH(60) && priceTrendingUp_15())
      currentMarket = "heavybull";
   if(isThisBarBEARISH(15) && isThisBarBEARISH(30) && isThisBarBULLISH(60))
      currentMarket = "bear";
   if(isThisBarBEARISH(15) && isThisBarBEARISH(30) && isThisBarBEARISH(60) && priceTrendingDown_15())
      currentMarket = "heavyBear";
   return currentMarket;
  }
//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+
double getRSI_1_14(const int index=0)
  {
   double rsi[1];
// reset error code
   ResetLastError();
// fill a part of the ma array with values from the indicator buffer that has 0 index
   if(CopyBuffer(RSIHandle_1_14,0,index,1,rsi) < 0)
     {
      // if the copying fails, tell the error code
      PrintFormat("Failed to copy data from the iMA indicator, error code %d",GetLastError());
      // quit with zero result - it means that the indicator is considered as not calculated
      return(0);
     }
   return(rsi[0]);
  }



//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+
double getMA_60_200(const int index=0)
  {
   double ma[1];
// reset error code
   ResetLastError();
// fill a part of the ma array with values from the indicator buffer that has 0 index
   if(CopyBuffer(MAHandle_60_200,0,index,1,ma) < 0)
     {
      // if the copying fails, tell the error code
      PrintFormat("Failed to copy data from the iMA indicator, error code %d",GetLastError());
      // quit with zero result - it means that the indicator is considered as not calculated
      return(0);
     }
   return(ma[0]);
  }

//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+
double getMA_60_50(const int index=0)
  {
   double ma[1];
// reset error code
   ResetLastError();
// fill a part of the ma array with values from the indicator buffer that has 0 index
   if(CopyBuffer(MAHandle_60_50,0,index,1,ma) < 0)
     {
      // if the copying fails, tell the error code
      PrintFormat("Failed to copy data from the iMA indicator, error code %d",GetLastError());
      // quit with zero result - it means that the indicator is considered as not calculated
      return(0);
     }
   return(ma[0]);
  }

//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+
double getMA_60_20(const int index=0)
  {
   double ma[1];
// reset error code
   ResetLastError();
// fill a part of the ma array with values from the indicator buffer that has 0 index
   if(CopyBuffer(MAHandle_60_20,0,index,1,ma) < 0)
     {
      // if the copying fails, tell the error code
      PrintFormat("Failed to copy data from the iMA indicator, error code %d",GetLastError());
      // quit with zero result - it means that the indicator is considered as not calculated
      return(0);
     }
   return(ma[0]);
  }

//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+
double getMA_60(const int index=0)
  {
   double ma[1];
// reset error code
   ResetLastError();
// fill a part of the ma array with values from the indicator buffer that has 0 index
   if(CopyBuffer(MAHandle_60,0,index,1,ma) < 0)
     {
      // if the copying fails, tell the error code
      PrintFormat("Failed to copy data from the iMA indicator, error code %d",GetLastError());
      // quit with zero result - it means that the indicator is considered as not calculated
      return(0);
     }
   return(ma[0]);
  }

//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+
double getMA_30_200(const int index=0)
  {
   double ma[1];
// reset error code
   ResetLastError();
// fill a part of the ma array with values from the indicator buffer that has 0 index
   if(CopyBuffer(MAHandle_30_200,0,index,1,ma) < 0)
     {
      // if the copying fails, tell the error code
      PrintFormat("Failed to copy data from the iMA indicator, error code %d",GetLastError());
      // quit with zero result - it means that the indicator is considered as not calculated
      return(0);
     }
   return(ma[0]);
  }

//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+
double getMA_30_50(const int index=0)
  {
   double ma[1];
// reset error code
   ResetLastError();
// fill a part of the ma array with values from the indicator buffer that has 0 index
   if(CopyBuffer(MAHandle_30_50,0,index,1,ma) < 0)
     {
      // if the copying fails, tell the error code
      PrintFormat("Failed to copy data from the iMA indicator, error code %d",GetLastError());
      // quit with zero result - it means that the indicator is considered as not calculated
      return(0);
     }
   return(ma[0]);
  }

//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+
double getMA_30_20(const int index=0)
  {
   double ma[1];
// reset error code
   ResetLastError();
// fill a part of the ma array with values from the indicator buffer that has 0 index
   if(CopyBuffer(MAHandle_30_20,0,index,1,ma) < 0)
     {
      // if the copying fails, tell the error code
      PrintFormat("Failed to copy data from the iMA indicator, error code %d",GetLastError());
      // quit with zero result - it means that the indicator is considered as not calculated
      return(0);
     }
   return(ma[0]);
  }

//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+
double getMA_30(const int index=0)
  {
   double ma[1];
// reset error code
   ResetLastError();
// fill a part of the ma array with values from the indicator buffer that has 0 index
   if(CopyBuffer(MAHandle_30,0,index,1,ma) < 0)
     {
      // if the copying fails, tell the error code
      PrintFormat("Failed to copy data from the iMA indicator, error code %d",GetLastError());
      // quit with zero result - it means that the indicator is considered as not calculated
      return(0);
     }
   return(ma[0]);
  }

//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+
double getMA_15_200(const int index=0)
  {
   double ma[1];
// reset error code
   ResetLastError();
// fill a part of the ma array with values from the indicator buffer that has 0 index
   if(CopyBuffer(MAHandle_15_200,0,index,1,ma) < 0)
     {
      // if the copying fails, tell the error code
      PrintFormat("Failed to copy data from the iMA indicator, error code %d",GetLastError());
      // quit with zero result - it means that the indicator is considered as not calculated
      return(0);
     }
   return(ma[0]);
  }

//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+
double getMA_15_50(const int index=0)
  {
   double ma[1];
// reset error code
   ResetLastError();
// fill a part of the ma array with values from the indicator buffer that has 0 index
   if(CopyBuffer(MAHandle_15_50,0,index,1,ma) < 0)
     {
      // if the copying fails, tell the error code
      PrintFormat("Failed to copy data from the iMA indicator, error code %d",GetLastError());
      // quit with zero result - it means that the indicator is considered as not calculated
      return(0);
     }
   return(ma[0]);
  }

//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+
double getMA_15_20(const int index=0)
  {
   double ma[1];
// reset error code
   ResetLastError();
// fill a part of the ma array with values from the indicator buffer that has 0 index
   if(CopyBuffer(MAHandle_15_20,0,index,1,ma) < 0)
     {
      // if the copying fails, tell the error code
      PrintFormat("Failed to copy data from the iMA indicator, error code %d",GetLastError());
      // quit with zero result - it means that the indicator is considered as not calculated
      return(0);
     }
   return(ma[0]);
  }

//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+
double getMA_15(const int index=0)
  {
   double ma[1];
// reset error code
   ResetLastError();
// fill a part of the ma array with values from the indicator buffer that has 0 index
   if(CopyBuffer(MAHandle_15,0,index,1,ma) < 0)
     {
      // if the copying fails, tell the error code
      PrintFormat("Failed to copy data from the iMA indicator, error code %d",GetLastError());
      // quit with zero result - it means that the indicator is considered as not calculated
      return(0);
     }
   return(ma[0]);
  }

//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+
double getMA_5_200(const int index=0)
  {
   double ma[1];
// reset error code
   ResetLastError();
// fill a part of the ma array with values from the indicator buffer that has 0 index
   if(CopyBuffer(MAHandle_5_200,0,index,1,ma) < 0)
     {
      // if the copying fails, tell the error code
      PrintFormat("Failed to copy data from the iMA indicator, error code %d",GetLastError());
      // quit with zero result - it means that the indicator is considered as not calculated
      return(0);
     }
   return(ma[0]);
  }

//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+
double getMA_5(const int index=0)
  {
   double ma[1];
// reset error code
   ResetLastError();
// fill a part of the ma array with values from the indicator buffer that has 0 index
   if(CopyBuffer(MAHandle_5,0,index,1,ma) < 0)
     {
      // if the copying fails, tell the error code
      PrintFormat("Failed to copy data from the iMA indicator, error code %d",GetLastError());
      // quit with zero result - it means that the indicator is considered as not calculated
      return(0);
     }
   return(ma[0]);
  }

//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+
double getMA_5_20(const int index=0)
  {
   double ma[1];
// reset error code
   ResetLastError();
// fill a part of the ma array with values from the indicator buffer that has 0 index
   if(CopyBuffer(MAHandle_5_20,0,index,1,ma) < 0)
     {
      // if the copying fails, tell the error code
      PrintFormat("Failed to copy data from the iMA indicator, error code %d",GetLastError());
      // quit with zero result - it means that the indicator is considered as not calculated
      return(0);
     }
   return(ma[0]);
  }

//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+
double getMA_5_9(const int index=0)
  {
   double ma[1];
// reset error code
   ResetLastError();
// fill a part of the ma array with values from the indicator buffer that has 0 index
   if(CopyBuffer(MAHandle_5_9,0,index,1,ma) < 0)
     {
      // if the copying fails, tell the error code
      PrintFormat("Failed to copy data from the iMA indicator, error code %d",GetLastError());
      // quit with zero result - it means that the indicator is considered as not calculated
      return(0);
     }
   return(ma[0]);
  }


//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+
double getMA_1_9(const int index=0)
  {
   double ma[1];
// reset error code
   ResetLastError();
// fill a part of the ma array with values from the indicator buffer that has 0 index
   if(CopyBuffer(MAHandle_1_9,0,index,1,ma) < 0)
     {
      // if the copying fails, tell the error code
      PrintFormat("Failed to copy data from the iMA indicator, error code %d",GetLastError());
      // quit with zero result - it means that the indicator is considered as not calculated
      return(0);
     }
   return(ma[0]);
  }

//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+
double getMA_1_20(const int index=0)
  {
   double ma[1];
// reset error code
   ResetLastError();
// fill a part of the ma array with values from the indicator buffer that has 0 index
   if(CopyBuffer(MAHandle_1_20,0,index,1,ma) < 0)
     {
      // if the copying fails, tell the error code
      PrintFormat("Failed to copy data from the iMA indicator, error code %d",GetLastError());
      // quit with zero result - it means that the indicator is considered as not calculated
      return(0);
     }
   return(ma[0]);
  }

//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+
double getMA_1_50(const int index=0)
  {
   double ma[1];
// reset error code
   ResetLastError();
// fill a part of the ma array with values from the indicator buffer that has 0 index
   if(CopyBuffer(MAHandle_1_50,0,index,1,ma) < 0)
     {
      // if the copying fails, tell the error code
      PrintFormat("Failed to copy data from the iMA indicator, error code %d",GetLastError());
      // quit with zero result - it means that the indicator is considered as not calculated
      return(0);
     }
   return(ma[0]);
  }

//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+
double getMA_1_200(const int index=0)
  {
   double ma[1];
// reset error code
   ResetLastError();
// fill a part of the ma array with values from the indicator buffer that has 0 index
   if(CopyBuffer(MAHandle_1_200,0,index,1,ma) < 0)
     {
      // if the copying fails, tell the error code
      PrintFormat("Failed to copy data from the iMA indicator, error code %d",GetLastError());
      // quit with zero result - it means that the indicator is considered as not calculated
      return(0);
     }
   return(ma[0]);
  }


//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+
bool checkPendingOrders()
  {
   int ord_total=OrdersTotal();
   if(ord_total > 0)
     {
      for(int i=ord_total-1; i>=0; i--)
        {
         ulong ticket=OrderGetTicket(i);
         if(OrderSelect(ticket) && OrderGetString(ORDER_SYMBOL)==Symbol())
           {

            double orderPrice = OrderGetDouble(ORDER_PRICE_OPEN);
            double gap = 4*Point;
            if((orderPrice > (currentPrice+gap) && isThisBarBEARISH())
               || (orderPrice < (currentPrice-gap) && isThisBarBULLISH()))
              {
               deletePendingScalp();
               //m_trade.OrderDelete(ticket);
               return false;
              }

           }
        }
     }
   return true;
  }


//+------------------------------------------------------------------+
//| Calculate open BUY positions                                         |
//+------------------------------------------------------------------+
int calculateBuyOrders()
  {
   int buys=0;

   for(int i=PositionsTotal()-1; i>=0; i--) // returns the number of current positions
      if(m_position.SelectByIndex(i))     // selects the position by index for further access to its properties
         if(m_position.Symbol()==Symbol() && m_position.PositionType() == POSITION_TYPE_BUY)
           {
            curBuys[i] = m_position.Profit();
            //   Alert("BUYS ",curBuys[i], " ",i);
            buys++;
           }
   return(buys);

  }

//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+
int calculateALLBuyOrders()
  {
   int buys=0;

   for(int i=PositionsTotal()-1; i>=0; i--) // returns the number of current positions
      if(m_position.SelectByIndex(i))     // selects the position by index for further access to its properties
         if(m_position.PositionType() == POSITION_TYPE_BUY)
            buys++;
   return(buys);

  }

//+------------------------------------------------------------------+
//| Calculate open BUYSTOP positions                                         |
//+------------------------------------------------------------------+
int calculateBuyStopOrders()
  {
   int buystops=0;

   for(int i=0; i<OrdersTotal(); i++)
     {
      if(OrderSelect(i,SELECT_BY_POS,MODE_TRADES)==false)
         break;
      if(OrderSymbol()==Symbol() && OrderMagicNumber()==MILLIONDOLLARBOT)
        {
         if(OrderType()==OP_BUYSTOP)
            buystops++;
        }
     }

   return(buystops);

  }

//+------------------------------------------------------------------+
//| Calculate open BUYLIMIT positions                                         |
//+------------------------------------------------------------------+
int calculateBuyLimitOrders()
  {
   int buylimits=0;

   for(int i=0; i<OrdersTotal(); i++)
     {
      if(OrderSelect(i,SELECT_BY_POS,MODE_TRADES)==false)
         break;
      if(OrderSymbol()==Symbol() && OrderMagicNumber()==MILLIONDOLLARBOT)
        {
         if(OrderType()==OP_BUYLIMIT)
            buylimits++;
        }
     }

   return(buylimits);

  }

//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+
int calculateSellLimitOrders()
  {
   int selllimits=0;

   for(int i=0; i<OrdersTotal(); i++)
     {
      if(OrderSelect(i,SELECT_BY_POS,MODE_TRADES)==false)
         break;
      if(OrderSymbol()==Symbol() && OrderMagicNumber()==MILLIONDOLLARBOT)
        {
         if(OrderType()==OP_SELLLIMIT)
            selllimits++;
        }
     }

   return(selllimits);

  }

//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+
int calculateSellStopOrders()
  {
   int sellstops=0;

   for(int i=0; i<OrdersTotal(); i++)
     {
      if(OrderSelect(i,SELECT_BY_POS,MODE_TRADES)==false)
         break;
      if(OrderSymbol()==Symbol() && OrderMagicNumber()==MILLIONDOLLARBOT)
        {
         if(OrderType()==OP_SELLSTOP)
            sellstops++;
        }
     }

   return(sellstops);

  }
//+------------------------------------------------------------------+
//| Calculate open SELL positions                                         |
//+------------------------------------------------------------------+
int calculateSellOrders()
  {
   int sells=0;

   for(int i=PositionsTotal()-1; i>=0; i--) // returns the number of current positions
      if(m_position.SelectByIndex(i))     // selects the position by index for further access to its properties
         if(m_position.Symbol()==Symbol() && m_position.PositionType() == POSITION_TYPE_SELL)
           {
            curSells[i] = m_position.Profit();
            //   Alert("SELLS ",curSells[i], " ",i);
            sells++;
           }
   return(sells);

  }

//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+
int calculateALLSellOrders()
  {
   int sells=0;

   for(int i=PositionsTotal()-1; i>=0; i--) // returns the number of current positions
      if(m_position.SelectByIndex(i))     // selects the position by index for further access to its properties
         if(m_position.PositionType() == POSITION_TYPE_SELL)
            sells++;
   return(sells);

  }

//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+
double checkCurrentBuyStopPrice()
  {
   double SYMBOL_buystopprice,gap;
   double potentialOrderPrice = (Bid+0.61);
//Alert("test");
   for(int i=0; i<OrdersTotal(); i++)
     {
      if(OrderSelect(i,SELECT_BY_POS,MODE_TRADES)==false)
         break;
      if(OrderSymbol()==Symbol() && OrderMagicNumber()==MILLIONDOLLARBOT)
        {
         if(OrderType()==OP_BUYSTOP)
           {
            SYMBOL_buystopprice=OrderOpenPrice();
            gap = percdiff(potentialOrderPrice, SYMBOL_buystopprice);
           }
        }
     }

   return(gap);

  }

//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+
int calculateNewOrders()
  {
   int news=0;

   for(int i=PositionsTotal()-1; i>=0; i--) // returns the number of current positions
      if(m_position.SelectByIndex(i))     // selects the position by index for further access to its properties
         if(TimeCurrent() - m_position.Time() < 10)
            news++;
   return(news);

  }

//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+
void deletePendingScalp()
  {
   int ord_total=OrdersTotal();
   if(ord_total > 0)
     {
      for(int i=ord_total-1; i>=0; i--)
        {
         ulong ticket=OrderGetTicket(i);
         if(OrderSelect(ticket) && OrderGetString(ORDER_SYMBOL)==Symbol() && (OrderComment()== "algorithm.V_BUYSTOP" || OrderComment()== "algorithm.V_SELLSTOP"))
           {
            m_trade.OrderDelete(ticket);
           }
        }
     }
   return;
  }

//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+
void deletePendingHODL()
  {
   int ord_total=OrdersTotal();
   if(ord_total > 0)
     {
      for(int i=ord_total-1; i>=0; i--)
        {
         ulong ticket=OrderGetTicket(i);
         if(OrderSelect(ticket) && OrderGetString(ORDER_SYMBOL)==Symbol() && (OrderComment()== "algorithm.V_BUYONE" || OrderComment()== "algorithm.V_BUYTWO"))
           {
            m_trade.OrderDelete(ticket);
           }
        }
     }
   return;
  }

//+------------------------------------------------------------------+
//| Calculate optimal lot size                                       |
//+------------------------------------------------------------------+
double lotSells()
  {
   double lot = MathMin(MathMax(NormalizeDouble(AccountBalance() / 3000,1),1),MathMax(NormalizeDouble(AccountBalance() / 700,1),0.2));


   if(lot > 50) // MAX Lots
     {
      lot = 50;
     }

   if(lot< 0.2) // MIN Lots
     {
      lot = 0.2;
     }

   return(lot);

  }


//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+
double lotBuys(int divider)
  {
   double lot = MathMax(NormalizeDouble(AccountBalance() / divider,1),0.2);

   if(lot > 50) // MAX Lots
     {
      lot = 50;
     }

   if(lot< 0.2) // MIN Lots
     {
      lot = 0.2;
     }

   return(lot);

  }

//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+
double getLastPrice()
  {
   if(priceLast==0)
      return currentPrice;
   return priceLast;
  }

//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+
bool priceGoingUp()
  {
   if(currentPrice>getLastPrice())
     {
      //   if((MAStatus_15 == "ABOVE" && calculateSellOrders() > 0) || (MAStatus_15 == "BELOW" && calculateBuyOrders() > 0))
      //   Alert("*******BOOOOOOOMMMMMM!!!!!!!******* ",Symbol()," Last Market: ",previousMarket," Market: ",currentMarket," barSize: ",barSize," Open ", iOpen(Symbol(),PERIOD_M1,0)," Current ", currentPrice, " Last Volume: ",volumeLast," Last Diff: ",lowestPrice3DayLast," Tick Count: ",tickCount);
      //   SendNotification("*******BOOOOOOOMMMMMM!!!!!!!******* "+Symbol()+" Last Market: "+previousMarket+" Market: "+currentMarket+" barSize: "+barSize+" Open "+ iOpen(Symbol(),PERIOD_M1,0)+" Current " +currentPrice+" Last Volume: "+volumeLast+" Last Diff: "+lowestPrice3DayLast+" Tick Count: "+tickCount);
      num=1;
      tickCount=0;
      xnotify=0;
      //deletePendingScalp();
      //deletePendingHODL();
      return true;
     }
// Alert("Price going down!");
   return false;
  }
//+------------------------------------------------------------------+
//| Check for open order conditions                                  |
//+------------------------------------------------------------------+
void CheckForOpen()
  {
   CheckForClose();
   continueOrders=true;
   getStepsLastBull(1);
   if(steps <= MAXSteps)
     {
      MAXOrders = 5; //defaultMAXOrders;
      orderCount = 1; //defaultOrderCount;
     }

   if(steps > MAXSteps)
     {
      MAXOrders = 1;
      orderCount = 1;
     }

// relative - M30
   if(AccountBalance() > 200
      && ((percdiff(currentPrice, priceHighest_M5) < 5
           && percdiff(currentPrice, priceHighest_M15) < 5
           && percdiff(currentPrice, priceHighest_M30) < 5
           && percdiff(priceLowest_M1, currentPrice) > 2
           && percdiff(priceLowest_M1_75, currentPrice) > 2
           && percdiff(priceLowest_M30, currentPrice) > 2
           && MAStatus_1_50 == "ABOVE")
          || (isThisBarBEARISH(60)
              && percdiff(priceLowest_M5, currentPrice) > 2
              && (isThisBarBEARISH(240)
                  || isThisBarBEARISH(999))))
     )
     {

      if(xnotify == 0)
        {
         //  Alert("INCREASING ORDERS");
         //  SendNotification("INCREASING ORDERS");
         xnotify++;
        }
      MAXOrders = MathMax(NormalizeDouble(AccountBalance() / 500, 1),3);
      orderCount = MathMax(NormalizeDouble(AccountBalance() / 2000, 1),1);
      if(steps > 5)
        {
         MAXOrders = MathMax(NormalizeDouble(AccountBalance() / 1000, 1),1);
         orderCount = MathMax(NormalizeDouble(AccountBalance() / 4000, 1),1);
        }
      if(steps > 7)
        {
         MAXOrders = MathMax(NormalizeDouble(AccountBalance() / 2000, 1),1);
         orderCount = MathMax(NormalizeDouble(AccountBalance() / 3000, 1),1);
        }

      if(((MAStatus_15_200 == "ABOVE"
           && MAStatus_15 == "ABOVE"
           && MAStatus_5 == "ABOVE"
           && MAStatus_1_50 == "ABOVE")
          || (percdiff(currentPrice, priceHighest_M15) < 2))
         && isThisBarBEARISH(60)
         && (isThisBarBEARISH(240)
             || isThisBarBEARISH(999))
        )
        {
         MAXOrders = MAXOrders * 2;
         orderCount = orderCount * 2;
        }
     }

   if(steps > 10)
     {
      //Alert(2);
      MAXOrders = MathMax(NormalizeDouble(AccountBalance() / 3000, 1),1);
      orderCount = MathMax(NormalizeDouble(AccountBalance() / 3000, 1),1);
     }

   if(steps > 15
      || (percdiff(priceLowest_M1, currentPrice) < 1
          && percdiff(priceLowest_M5, currentPrice) < 1
          && percdiff(priceLowest_M15, currentPrice) < 1)
      || (priceTrendingUp_15() && priceRelativelyLow())
      || currentMarket == "bull")
     {
      // Alert(1);
      MAXOrders = 1;
      orderCount = 1;
     }

   if(steps > 20 || percdiff(priceLowest_M30, currentPrice) < 0.5)
     {
      continueOrders = false;
      MAXOrders = 0;
      orderCount = 0;
     }

//if(/*steps > MAXSteps || */calculateSellOrders() > MAXOrders)
//   continueOrders = false;
//Alert(MAXOrders," ",orderCount, " ",continueOrders);
//--- go trading only for first tiks of new bar
// if(Volume[0]<volumeLast)

// ********************* BEGIN ORDERS LOGIC *********************

//Alert("here ", MAXOrders, " ", MAXSteps);
//Alert(priceLowest_M1);
//Alert(priceLowest_M1_75);
// Risk Management
   if(AccountBalance() > 500)
     {
      accountMarg = 300;
      maxLimits=30;
      maxLoop=20;
      lowestProfit = -100;
     }
   if(AccountBalance() <= 500)
     {
      accountMarg = 500;
      maxLimits=10;
      maxLoop=2;
      lowestProfit = -75;
     }
   if(AccountBalance() <= 100)
     {
      accountMarg = 800;
      maxLimits=10;
      maxLoop=1;
      lowestProfit = -20;
     }
   if(AccountBalance() <= 50)
     {
      accountMarg = 1000;
      maxLimits=1;
      maxLoop=1;
      lowestProfit = -10;
     }
   if(AccountBalance() <= 30)
     {
      accountMarg = 1500;
      maxLimits=1;
      maxLoop=1;
      lowestProfit = -6;
     }
   if(AccountBalance() <= 15)
     {
      accountMarg = 2000;
      maxLimits=1;
      maxLoop=1;
      lowestProfit = -2.5;
     }

// Alert(priceHighest_M1_75, " ", Bid, " ", (priceHighest_M1_75 - Bid));
//Alert(calculateNewOrders());
   if(((calculateBuyStopOrders() + calculateSellStopOrders()) > maxLimits && !checkPendingOrders())
      || (AccountInfoDouble(ACCOUNT_MARGIN_LEVEL) < accountMarg
          && ((calculateALLBuyOrders() + calculateALLSellOrders()) != 0))
      || (calculateNewOrders() > 1)
     )
     {
      deletePendingHODL();
      deletePendingScalp();
     }

  // Alert(percdiff(currentPrice, priceHighest_M1));
  // Alert("75 ",percdiff(currentPrice, priceHighest_M1_75));

//  Alert(getMA_60_20(), " ", currentPrice);
//Alert(percdiff(8635, 8639), " ", getLowestPrice(60,2), " ", currentPrice);
   if((AccountInfoDouble(ACCOUNT_MARGIN_LEVEL) > accountMarg
       || (calculateALLBuyOrders() == 0 && calculateALLSellOrders() == 0))
      && (calculateBuyStopOrders() + calculateSellStopOrders()) <= maxLimits) // make sure we have enough money
     {
      // *** DAY TRADING ***

      // SELL Order Logic
      if(((isThisBarBEARISH()
           && isThisBarBEARISH(5)
           && (isThisBarBEARISH(15)
               || priceTrendingDown_1()
               || isThisBarBEARISH(30)
               || isThisBarBEARISH(60)
               || isThisBarBEARISH(240)
              ))
          || ((isThisBarBEARISH() || isThisBarBULLISH()) && currentPrice < priceLast)) //&& !priceGoingUp()
         && (
            //getMA_1_200() > currentHigh_M1
            //  && getMA_1_50() > currentHigh_M1
            //   percdiff(currentPrice, getMA_5_9()) < 0.2
            //  && percdiff(currentPrice, getMA_5_20()) < 0.7
           // getMA_1_20() > currentPrice
            // && getMA_5_9() > currentHigh_M5
            //     && getMA_5_20() > currentHigh_M5
            //   && getMA_15_20() > currentHigh_M15
            //   && isThisBarBEARISH(30)
            //   && isThisBarBEARISH(15)
             isThisBarBEARISH()
           // && isThisBarBEARISH(5)
            && (isThisBarBEARISH(5)
                || isThisBarBEARISH(15)
                || isThisBarBEARISH(30)
               )
         //   && (getMA_15() < currentPrice || getMA_15() < getMA_15_20())
         )
        )
        {

         //  SendNotification("taking order now");
         if(
         //   percdiff(getMA_5_9(), currentHigh_M5) < 0.4
             iLow(Symbol(),PERIOD_M30,1) < currentPrice
            && percdiff(iLow(Symbol(),PERIOD_M30,0),currentPrice) >= 0.05
            && percdiff(priceLowest_M1, currentPrice) >= 0.4
            && percdiff(priceLowest_M1_75, currentPrice) >= 0.2
            && percdiff(priceLowest_M1_37, currentPrice) >= 0.15
            //   getMA_60_20() > currentHigh_H1
            //   || getMA_15_20() > currentHigh_M15
            //   || getMA_5_9() > currentHigh_M5
         )
           {
            for(int i = 0; i < maxLoop; i++)
              {
               orderPlaced=OrderSend(Symbol(),OP_SELLSTOP,lotSells(),(Ask-(7*Point)),3,0,0,"algorithm.V_SELLSTOP",MILLIONDOLLARBOT,0,Red);
              }
            //deletePendingScalp();
            continueOrders = true;
            notifyCount = 0;
            return;
           }
        }

      // BUY Order Logic
      if(((isThisBarBULLISH()
           && isThisBarBULLISH(5)
           && (isThisBarBULLISH(15)
               || priceTrendingUp_1()
               || isThisBarBULLISH(30)
               || isThisBarBULLISH(60)
               || isThisBarBULLISH(240)
              ))
          || ((isThisBarBEARISH() || isThisBarBULLISH()) && currentPrice > priceLast)) // && priceGoingUp()
         && (
            //getMA_1_200() < currentLow_M1
            //  && getMA_1_50() < currentLow_M1
            //   percdiff(getMA_5_9(), currentPrice) < 0.2
            //&& percdiff(getMA_5_20(), currentPrice) < 0.7
           // getMA_1_20() < currentPrice
            //  && getMA_5_9() < currentLow_M5
            //    && getMA_5_20() < currentLow_M5
            //  && getMA_15_20() < currentLow_M15
            //    && isThisBarBULLISH(30)
            //    && isThisBarBULLISH(15)
            isThisBarBULLISH()
          //  && isThisBarBULLISH(5)
            && (isThisBarBULLISH(5)
                || isThisBarBULLISH(15)
                || isThisBarBULLISH(30)
               )
          //  && (getMA_15() > currentPrice || getMA_15() > getMA_15_20())
         )
        )

        {
         // Alert("here2");
         //  SendNotification("taking order now");
         if(
           // percdiff(currentLow_M5, getMA_5_9()) < 0.4
             iHigh(Symbol(),PERIOD_M30,1) > currentPrice
            && percdiff(currentPrice,iHigh(Symbol(),PERIOD_M30,0)) >= 0.05
            && percdiff(currentPrice, priceHighest_M1) >= 0.4
            && percdiff(currentPrice, priceHighest_M1_75) >= 0.2
            && percdiff(currentPrice, priceHighest_M1_37) >= 0.15
            //    getMA_60_20() < currentLow_H1
            //    || getMA_15_20() < currentLow_M15
            //    || getMA_5_9() < currentLow_M5
         )
           {
            for(int i = 0; i < maxLoop; i++)
              {
               orderPlaced=OrderSend(Symbol(),OP_BUYSTOP,lotSells(),(Bid+(7*Point)),3,0,0,"algorithm.V_BUYSTOP",MILLIONDOLLARBOT,0,Red);
              }
            //deletePendingScalp();
            continueOrders = true;
            notifyCount = 0;
            return;
           }
        }

     }
//
//   if(iClose(Symbol(),PERIOD_H1,0) < iHigh(Symbol(),PERIOD_H1,0))
//      Alert("Z ",percdiff(iClose(Symbol(),PERIOD_H1,0),iHigh(Symbol(),PERIOD_H1,0)));
//
//   if(iClose(Symbol(),PERIOD_H1,0) < iHigh(Symbol(),PERIOD_H1,1))
//      Alert("O ",percdiff(iClose(Symbol(),PERIOD_H1,0),iHigh(Symbol(),PERIOD_H1,1)));
//
//   Alert("ALL UP ", allMAUp()," ALL DOWN ",allMADown());
   CheckForClose();
  }

// ********************* END ORDERS LOGIC *********************

//+------------------------------------------------------------------+
//| Check for close order conditions                                 |
//+------------------------------------------------------------------+
void CheckForClose()
  {
   takeProfit = MathMax(MathMin(NormalizeDouble(AccountBalance() / 500,0),50),0.5);
   if(steps > 3)
     {
      takeProfit = MathMax(MathMin(NormalizeDouble(AccountBalance() / 1000,0),30),0.5);
     }
   if(steps > 5)
     {
      takeProfit = MathMax(MathMin(NormalizeDouble(AccountBalance() / 3000,0),20),0.5);
     }
   takeProfit=1;
   if(lotSells() < 0.5)
      takeProfit = 0.6;


   if(MASignal_5 == "BUY" /*MAStatus_15 == "CROSSING" && MAReachUp_15 == true && MAStatus_1 == "BELOW"*/)
     {
      // takeProfit = 1;
      // closeAllOrdersALL(1); // only close sell orders
     }

   if(MASignal_5 == "SELL" /*MAStatus_15 == "CROSSING" && MAReachDown_15 == true && MAStatus_1 == "ABOVE"*/)
     {
      // closeAllOrdersALL(0); // only close buy orders
     }

   for(int i=PositionsTotal()-1; i>=0; i--) // returns the number of current position
      if(m_position.SelectByIndex(i))     // selects the position by index for further access to its properties
         if(m_position.Symbol()==Symbol())
           {

            // check for DAY TRADES
            if(m_position.Comment() == "algorithm.V_SELLSTOP" || m_position.Comment() == "algorithm.V_BUYSTOP")
              {

               //Alert(m_position.Volume());
               if(m_position.Profit() < lowestProf[i])
                  lowestProf[i]=m_position.Profit();
               if(m_position.Profit() > highestProf[i])
                  highestProf[i]=m_position.Profit();
               //  Alert("LOWEST PROFIT ",lowestProf[i]);
               //   Alert("HIGHEST PROFIT ",highestProf[i]);

               orderTime[i] = TimeCurrent() - m_position.Time();
               //   Alert("elapsed ", orderTime[i]);

               // Take Profit Logic
               if(lowestProf[i] < lowestProfit || orderTime[i] > 15)
                  takeProfit = MathMin((m_position.Volume() * 2),1);

               if((m_position.Profit() >= takeProfit && m_position.PositionType() == POSITION_TYPE_SELL)
                  || (m_position.Profit() >= takeProfit && m_position.PositionType() == POSITION_TYPE_BUY))
                 {
                  m_trade.PositionClose(m_position.Ticket()); // close a position by the specified symbol
                  SendNotification("Thank you Lord for MANY Blessings!");
                  deletePendingScalp();
                 }
              }

            // check for SWING TRADES
            if(m_position.Comment() == "algorithm.V_SELLONE" || m_position.Comment() == "algorithm.V_BUYONE")
              {
               // Take Profit Logic
               if(m_position.Profit() >= MathMin(NormalizeDouble(AccountBalance() / 20,0),5) || (getRSI_1_14() <= 33 && m_position.Profit() >= 0.5))
                 {
                  if(m_position.PositionType() == POSITION_TYPE_SELL)
                    {
                     sellcount1=0;
                    }
                  if(m_position.PositionType() == POSITION_TYPE_BUY)
                    {

                     buycount1=0;
                    }
                  m_trade.PositionClose(m_position.Ticket()); // close a position by the specified symbol
                 }
              }

            if(m_position.Comment() == "algorithm.V_SELLTWO" || m_position.Comment() == "algorithm.V_BUYTWO")
              {
               // Take Profit Logic
               if(m_position.Profit() >= MathMin(NormalizeDouble(AccountBalance() / 5,0),10))
                 {
                  if(m_position.PositionType() == POSITION_TYPE_SELL)
                    {
                     sellcount2=0;
                    }
                  if(m_position.PositionType() == POSITION_TYPE_BUY)
                    {
                     buycount2=0;
                    }
                  m_trade.PositionClose(m_position.Ticket()); // close a position by the specified symbol
                 }
              }
           }
  }

//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+
void CheckLevels()
  {
   currentPrice=iClose(Symbol(),PERIOD_M1,0);
   currentLow_M1=iLow(Symbol(),PERIOD_M1,0);
   currentLow_M5=iLow(Symbol(),PERIOD_M5,0);
   currentLow_M15=iLow(Symbol(),PERIOD_M15,0);
   currentLow_M30=iLow(Symbol(),PERIOD_M30,0);
   currentLow_H1=iLow(Symbol(),PERIOD_H1,0);
   currentHigh_M1=iHigh(Symbol(),PERIOD_M1,0);
   currentHigh_M5=iHigh(Symbol(),PERIOD_M5,0);
   currentHigh_M15=iHigh(Symbol(),PERIOD_M15,0);
   currentHigh_M30=iHigh(Symbol(),PERIOD_M30,0);
   currentHigh_H1=iHigh(Symbol(),PERIOD_H1,0);
   steps = getStepsLastBull(1);
   barSize=MathAbs((iOpen(Symbol(),PERIOD_M1,0)-currentPrice)*100);
   highestPrice3Day=getHighestPrice(999,3);
   lowestPrice3Day=getLowestPrice(999,3);
   highestPrice3Day_diff=percdiff(currentPrice,getHighestPrice(999,3));
   lowestPrice3Day_diff=percdiff(getLowestPrice(999,3),currentPrice);
   priceHighest_M1=getHighestPrice(1,300);
   priceHighest_M1_75=getHighestPrice(1,75);
   priceHighest_M1_37=getHighestPrice(1,37);
   priceLowest_M1=getLowestPrice(1,300);
   priceLowest_M1_75=getLowestPrice(1,75);
   priceLowest_M1_37=getLowestPrice(1,37);
   priceHighest_M5=getHighestPrice(5,300);
   priceLowest_M5=getLowestPrice(5,300);
   priceHighest_M15=getHighestPrice(15,300);
   priceLowest_M15=getLowestPrice(15,300);
   priceHighest_M30=getHighestPrice(30,300);
   priceLowest_M30=getLowestPrice(30,300);

// Pending Orders
   checkPendingOrders();
// last Bulls
   lastBull1 = getStepsLastBull(1,0) - 1;
   lastBull2 = lastBull1 + (getStepsLastBull(1,lastBull1 + 1));
   lastBull3 = lastBull2 + (getStepsLastBull(1,lastBull2 + 1));
   lastBull4 = lastBull3 + (getStepsLastBull(1,lastBull3 + 1));
   lastBull5 = lastBull4 + (getStepsLastBull(1,lastBull4 + 1));
   lastBull6 = lastBull5 + (getStepsLastBull(1,lastBull5 + 1));
   lastBull7 = lastBull6 + (getStepsLastBull(1,lastBull6 + 1));
   lastBull8 = lastBull7 + (getStepsLastBull(1,lastBull7 + 1));
   lastBull9 = lastBull8 + (getStepsLastBull(1,lastBull8 + 1));
   lastBull10 = lastBull9 + (getStepsLastBull(1,lastBull9 + 1));

// Check MA and calculate signal
// 15_200 Minute
   MASignal_15_200 = "Calculating...";
   if(getMA_15_200() > currentHigh_M15 && percdiff(currentHigh_M15, getMA_15_200()) > 0.1)
     {
      MAStatus_15_200 = "ABOVE";
      MAReachUp_15_200 = true;
     }
   if(getMA_15_200() < currentLow_M15 && percdiff(getMA_15_200(), currentLow_M15) > 0.1)
     {
      MAStatus_15_200 = "BELOW";
      MAReachDown_15_200 = true;
     }
   if(getMA_15_200() > currentLow_M15 && getMA_15_200() < currentHigh_M15)
     {
      MAStatus_15_200 = "CROSSING";
     }
   if(MAReachUp_15_200 == true && MAStatusLast_15_200 == "CROSSING" /*&& MAStatus_15_200 == "BELOW"*/)
     {
      MAReachUp_15_200 = false;
      MASignal_15_200 = "BUY";
     }
   if(MAReachDown_15_200 == true && MAStatusLast_15_200 == "CROSSING" /*&& MAStatus_15_200 == "ABOVE"*/)
     {
      MAReachDown_15_200 = false;
      MASignal_15_200 = "SELL";
     }

// 15 Minute
   MASignal_15 = "Calculating...";
   if(getMA_15() > currentHigh_M15 && percdiff(currentHigh_M15, getMA_15()) > 0.1)
     {
      MAStatus_15 = "ABOVE";
      MAReachUp_15 = true;
     }
   if(getMA_15() < currentLow_M15 && percdiff(getMA_15(), currentLow_M15) > 0.1)
     {
      MAStatus_15 = "BELOW";
      MAReachDown_15 = true;
     }
   if(getMA_15() > currentLow_M15 && getMA_15() < currentHigh_M15)
     {
      MAStatus_15 = "CROSSING";
     }
   if(MAReachUp_15 == true && MAStatusLast_15 == "CROSSING" /*&& MAStatus_15 == "BELOW"*/)
     {
      MAReachUp_15 = false;
      MASignal_15 = "BUY";
     }
   if(MAReachDown_15 == true && MAStatusLast_15 == "CROSSING" /*&& MAStatus_15 == "ABOVE"*/)
     {
      MAReachDown_15 = false;
      MASignal_15 = "SELL";
     }

// 5 Minute
   MASignal_5 = "Calculating...";
   if(getMA_5() > currentHigh_M5 && percdiff(currentHigh_M5, getMA_5()) > 0.1)
     {
      MAStatus_5 = "ABOVE";
      MAReachUp_5 = true;
     }
   if(getMA_5() < currentLow_M5 && percdiff(getMA_5(), currentLow_M5) > 0.1)
     {
      MAStatus_5 = "BELOW";
      MAReachDown_5 = true;
     }
   if(getMA_5() > currentLow_M5 && getMA_5() < currentHigh_M5)
     {
      MAStatus_5 = "CROSSING";
     }
   if(MAReachUp_5 == true && MAStatusLast_5 == "CROSSING" /*&& MAStatus_5 == "BELOW"*/)
     {
      MAReachUp_5 = false;
      MASignal_5 = "BUY";
     }
   if(MAReachDown_5 == true && MAStatusLast_5 == "CROSSING" /*&& MAStatus_5 == "ABOVE"*/)
     {
      MAReachDown_5 = false;
      MASignal_5 = "SELL";
     }

// 1 Minute (9 period))
   MASignal_1_9 = "Calculating...";
   if(getMA_1_9() > currentHigh_M1 && percdiff(currentHigh_M1, getMA_1_9()) > 0.01)
     {
      MAStatus_1_9 = "ABOVE";
      MAReachUp_1_9 = true;
     }
   if(getMA_1_9() < currentLow_M1 && percdiff(getMA_1_9(), currentLow_M1) > 0.01)
     {
      MAStatus_1_9 = "BELOW";
      MAReachDown_1_9 = true;
     }
   if(getMA_1_9() > currentLow_M1 && getMA_1_9() < currentHigh_M1)
     {
      MAStatus_1_9 = "CROSSING";
     }
   if(MAReachUp_1_9 == true && MAStatusLast_1_9 == "CROSSING" /*&& MAStatus_1 == "BELOW"*/)
     {
      MAReachUp_1_9 = false;
      MASignal_1_9 = "BUY";
     }
   if(MAReachDown_1_9 == true && MAStatusLast_1_9 == "CROSSING" /*&& MAStatus_1 == "ABOVE"*/)
     {
      MAReachDown_1_9 = false;
      MASignal_1_9 = "SELL";
     }

// 1 Minute (50 period))
   MASignal_1_50 = "Calculating...";
   if(getMA_1_50() > currentHigh_M1 && percdiff(currentHigh_M1, getMA_1_50()) > 0.1)
     {
      MAStatus_1_50 = "ABOVE";
      MAReachUp_1_50 = true;
     }
   if(getMA_1_50() < currentLow_M1 && percdiff(getMA_1_50(), currentLow_M1) > 0.1)
     {
      MAStatus_1_50 = "BELOW";
      MAReachDown_1_50 = true;
     }
   if(getMA_1_50() > currentLow_M1 && getMA_1_50() < currentHigh_M1)
     {
      MAStatus_1_50 = "CROSSING";
     }
   if(MAReachUp_1_50 == true && MAStatusLast_1_50 == "CROSSING" /*&& MAStatus_1 == "BELOW"*/)
     {
      MAReachUp_1_50 = false;
      MASignal_1_50 = "BUY";
     }
   if(MAReachDown_1_50 == true && MAStatusLast_1_50 == "CROSSING" /*&& MAStatus_1 == "ABOVE"*/)
     {
      MAReachDown_1_50 = false;
      MASignal_1_50 = "SELL";
     }

  }

//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+
bool allMAUp()
  {
   double pdValue1 = 0.01;

   if(
      getMA_1_9() > currentHigh_M1 && percdiff(currentHigh_M1, getMA_1_9()) > pdValue1
      && getMA_1_20() > currentHigh_M1 && percdiff(currentHigh_M1, getMA_1_20()) > pdValue1
      && getMA_1_50() > currentHigh_M1 && percdiff(currentHigh_M1, getMA_1_50()) > pdValue1
      && getMA_1_200() > currentHigh_M1 && percdiff(currentHigh_M1, getMA_1_200()) > pdValue1
      && getMA_5_9() > currentHigh_M5 && percdiff(currentHigh_M5, getMA_5_9()) > pdValue1
      && getMA_5_20() > currentHigh_M5 && percdiff(currentHigh_M5, getMA_5_20()) > pdValue1
      && getMA_5() > currentHigh_M5 && percdiff(currentHigh_M5, getMA_5()) > pdValue1
      && getMA_5_200() > currentHigh_M5 && percdiff(currentHigh_M5, getMA_5_200()) > pdValue1
      && getMA_15() > currentHigh_M15 && percdiff(currentHigh_M15, getMA_15()) > pdValue1
      && getMA_15_20() > currentHigh_M15 && percdiff(currentHigh_M15, getMA_15_20()) > pdValue1
      && getMA_15_50() > currentHigh_M15 && percdiff(currentHigh_M15, getMA_15_50()) > pdValue1
      && getMA_15_200() > currentHigh_M15 && percdiff(currentHigh_M15, getMA_15_200()) > pdValue1
      && getMA_30() > currentHigh_M30 && percdiff(currentHigh_M30, getMA_30()) > pdValue1
      && getMA_30_20() > currentHigh_M30 && percdiff(currentHigh_M30, getMA_30_20()) > pdValue1
      && getMA_30_50() > currentHigh_M30 && percdiff(currentHigh_M30, getMA_30_50()) > pdValue1
      && getMA_30_200() > currentHigh_M30 && percdiff(currentHigh_M30, getMA_30_200()) > pdValue1
      && getMA_60() > currentHigh_H1 && percdiff(currentHigh_H1, getMA_60()) > pdValue1
      && getMA_60_20() > currentHigh_H1 && percdiff(currentHigh_H1, getMA_60_20()) > pdValue1
      && getMA_60_50() > currentHigh_H1 && percdiff(currentHigh_H1, getMA_60_50()) > pdValue1
      && getMA_60_200() > currentHigh_H1 && percdiff(currentHigh_H1, getMA_60_200()) > pdValue1
   )
     {
      return true;
     }
   return false;
  }

//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+
bool allMADown()
  {
   double pdValue1 = 0.01;
   if(
      getMA_1_9() < currentLow_M1 && percdiff(getMA_1_9(), currentLow_M1) > pdValue1
      && getMA_1_20() < currentLow_M1 && percdiff(getMA_1_20(), currentLow_M1) > pdValue1
      && getMA_1_50() < currentLow_M1 && percdiff(getMA_1_50(), currentLow_M1) > pdValue1
      && getMA_1_200() < currentLow_M1 && percdiff(getMA_1_200(), currentLow_M1) > pdValue1
      && getMA_5_9() < currentLow_M5 && percdiff(getMA_5_9(), currentLow_M5) > pdValue1
      && getMA_5_20() < currentLow_M5 && percdiff(getMA_5_20(), currentLow_M5) > pdValue1
      && getMA_5() < currentLow_M5 && percdiff(getMA_5(), currentLow_M5) > pdValue1
      && getMA_5_200() < currentLow_M5 && percdiff(getMA_5_200(), currentLow_M5) > pdValue1
      && getMA_15() < currentLow_M15 && percdiff(getMA_15(), currentLow_M15) > pdValue1
      && getMA_15_20() < currentLow_M15 && percdiff(getMA_15_20(), currentLow_M15) > pdValue1
      && getMA_15_50() < currentLow_M15 && percdiff(getMA_15_50(), currentLow_M15) > pdValue1
      && getMA_15_200() < currentLow_M15 && percdiff(getMA_15_200(), currentLow_M15) > pdValue1
      && getMA_30() < currentLow_M30 && percdiff(getMA_30(), currentLow_M30) > pdValue1
      && getMA_30_20() < currentLow_M30 && percdiff(getMA_30_20(), currentLow_M30) > pdValue1
      && getMA_30_50() < currentLow_M30 && percdiff(getMA_30_50(), currentLow_M30) > pdValue1
      && getMA_30_200() < currentLow_M30 && percdiff(getMA_30_200(), currentLow_M30) > pdValue1
      && getMA_60() < currentLow_H1 && percdiff(getMA_60(), currentLow_H1) > pdValue1
      && getMA_60_20() < currentLow_H1 && percdiff(getMA_60_20(), currentLow_H1) > pdValue1
      && getMA_60_50() < currentLow_H1 && percdiff(getMA_60_50(), currentLow_H1) > pdValue1
      && getMA_60_200() < currentLow_H1 && percdiff(getMA_60_200(), currentLow_H1) > pdValue1
   )
     {
      return true;
     }
   return false;

  }


//+------------------------------------------------------------------+
//| Close All Orders                                                 |
//+------------------------------------------------------------------+
void closeAllOrders()
  {
   for(int i=PositionsTotal()-1; i>=0; i--) // returns the number of current positions
      if(m_position.SelectByIndex(i))     // selects the position by index for further access to its properties
         if(m_position.Symbol()==Symbol() && m_position.Profit() > 0)
            m_trade.PositionClose(m_position.Ticket()); // close a position by the specified symbol
  }

//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+
void closeAllOrdersALL(int type)
  {
   for(int i=PositionsTotal()-1; i>=0; i--) // returns the number of current positions
      if(m_position.SelectByIndex(i))     // selects the position by index for further access to its properties
         if(m_position.Symbol()==Symbol() && m_position.PositionType() == type)
           {
            m_trade.PositionClose(m_position.Ticket()); // close a position by the specified symbol
           }
  }

//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+
double getHighestPrice(int time=1, int period=0)
  {
   return iHigh(NULL,setTimeFrame(time),iHighest(NULL, setTimeFrame(time), MODE_HIGH, period, 0));
  }

//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+
double getLowestPrice(int time=1, int period=0)
  {
   return iLow(NULL,setTimeFrame(time),iLowest(NULL, setTimeFrame(time), MODE_LOW, period, 0));
  }

//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+
bool priceRelativelyHigh()
  {
   if(percdiff(currentPrice, priceHighest_M1) < 0.5 && percdiff(currentPrice, priceHighest_M1_75) < 0.5)
     {
      // Alert(percdiff(currentPrice, priceHighest_M1_75));
      return true;
     }
   return false;
  }

//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+
bool priceRelativelyLow()
  {
   if(percdiff(priceLowest_M1, currentPrice) < 0.5 || percdiff(currentPrice, priceLowest_M1_75) < 0.5)
     {
      // Alert(percdiff(currentPrice, priceLowest_M1_75));
      return true;
     }
   return false;
  }
//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+
bool priceTrendingUp_1()
  {
   if(currentPrice > iClose(Symbol(),PERIOD_M1,1)
      && currentPrice > iClose(Symbol(),PERIOD_M1,5)
      && currentPrice > iClose(Symbol(),PERIOD_M1,10)
      && isThisBarBULLISH()
     )
      return true;
   return false;
  }

//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+
bool priceTrendingDown_1()
  {
   if(currentPrice < iClose(Symbol(),PERIOD_M1,1)
      && currentPrice < iClose(Symbol(),PERIOD_M1,5)
      && currentPrice < iClose(Symbol(),PERIOD_M1,10)
      && isThisBarBEARISH()
     )
      return true;
   return false;
  }

//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+
bool priceTrendingUp_5()
  {
   if(iClose(Symbol(),PERIOD_M5,0) > iClose(Symbol(),PERIOD_M5,1)
      && iClose(Symbol(),PERIOD_M5,0) > iClose(Symbol(),PERIOD_M5,2)
      && isThisBarBULLISH(5,0)
      && isThisBarBULLISH(5,1)
     )
      return true;
   return false;
  }

//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+
bool priceTrendingDown_5()
  {
   if(iClose(Symbol(),PERIOD_M5,0) < iClose(Symbol(),PERIOD_M5,1)
      && iClose(Symbol(),PERIOD_M5,0) < iClose(Symbol(),PERIOD_M5,2)
      && isThisBarBEARISH(5,0)
      && isThisBarBEARISH(5,1)
     )
      return true;
   return false;
  }

//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+
bool priceTrendingUp_15()
  {
   if(iClose(Symbol(),PERIOD_M15,0) > iClose(Symbol(),PERIOD_M15,1)
      && iClose(Symbol(),PERIOD_M15,0) > iClose(Symbol(),PERIOD_M15,2)
      && isThisBarBULLISH(15,0)
      && isThisBarBULLISH(15,1)
     )
      return true;
   return false;
  }

//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+
bool priceTrendingDown_15()
  {
   if(iClose(Symbol(),PERIOD_M15,0) < iClose(Symbol(),PERIOD_M15,1)
      && iClose(Symbol(),PERIOD_M15,0) < iClose(Symbol(),PERIOD_M15,2)
      && isThisBarBEARISH(15,0)
      && isThisBarBEARISH(15,1)
     )
      return true;
   return false;
  }

//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+
void getComment()
  {

   for(int i=PositionsTotal()-1; i>=0; i--) // returns the number of current positions
      if(m_position.SelectByIndex(i))     // selects the position by index for further access to its properties
         if(m_position.Symbol()==Symbol())
            Alert(m_position.Comment());
   return;
  }
//+------------------------------------------------------------------+
//| OnTick function                                                  |
//+------------------------------------------------------------------+
void OnTick()
  {
   tickCount++;
   CheckLevels();
   CheckForOpen();
   CheckForClose();
   calculateBuyOrders();
   calculateSellOrders();
  }
//+------------------------------------------------------------------+


//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+
void OnTimer()
  {
   priceLast=currentPrice;
   lowLast_M1=currentLow_M1;
   lowLast_M5=currentLow_M5;
   lowLast_M15=currentLow_M15;
   lowLast_M30=currentLow_M30;
   lowLast_H1=currentLow_H1;
   highLast_M1=currentHigh_M1;
   highLast_M5=currentHigh_M5;
   highLast_M15=currentHigh_M15;
   highLast_M30=currentHigh_M30;
   highLast_H1=currentHigh_H1;
   previousMarket=currentMarket;
   volumeLast=Volume[0];
   barSizeLast=(iOpen(Symbol(),PERIOD_M1,0)-currentPrice)*100;
   lowestPrice3DayLast = lowestPrice3Day_diff;
   MAStatusLast_15_200 = MAStatus_15_200;
   MAStatusLast_15 = MAStatus_15;
   MAStatusLast_5 = MAStatus_5;
   MAStatusLast_1_9 = MAStatus_1_9;
   MAStatusLast_1_50 = MAStatus_1_50;


  } // End OnTimer
//+------------------------------------------------------------------+

//+------------------------------------------------------------------+

//+------------------------------------------------------------------+
